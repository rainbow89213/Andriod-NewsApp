# 分类状态保持功能

## 📋 功能说明

每个分类（全部、科技、经济、体育等）都独立维护自己的：
- ✅ 加载进度（offset）
- ✅ 是否还有更多数据（hasMoreData）
- ✅ 已加载的新闻列表

切换分类时，**自动保存和恢复状态**，无需重新加载。

---

## 🎯 解决的问题

### 问题1：数据丢失
**之前**：
```
科技板块 → 加载2条 → 点击"加载更多" → 再加载2条（总共4条）
  ↓
切换到"经济"板块
  ↓
再切换回"科技"板块
  ↓
只显示2条（之前加载的4条丢失了！）❌
```

**现在**：
```
科技板块 → 加载2条 → 点击"加载更多" → 再加载2条（总共4条）
  ↓
切换到"经济"板块（自动保存科技板块状态）
  ↓
再切换回"科技"板块（自动恢复）
  ↓
显示4条（之前加载的数据都在！）✅
```

### 问题2：重复加载
**之前**：每次切换分类都从服务器重新加载，浪费流量

**现在**：
- 第一次访问：从服务器加载
- 再次访问：直接恢复，不重新加载

---

## 🔧 技术实现

### 1. 数据结构

```java
// 为每个分类维护独立的状态
private Map<String, Integer> categoryOffsetMap;      // 各分类的offset
private Map<String, Boolean> categoryHasMoreMap;     // 各分类是否还有数据
private Map<String, List<NewsItem>> categoryDataMap; // 各分类的数据列表
```

### 2. 保存状态

切换分类时，自动保存当前分类的状态：

```java
// 分类key
String oldCategoryKey = currentCategory == null ? "all" : currentCategory;

// 保存offset、hasMoreData、数据列表
categoryOffsetMap.put(oldCategoryKey, currentOffset);
categoryHasMoreMap.put(oldCategoryKey, hasMoreData);
categoryDataMap.put(oldCategoryKey, new ArrayList<>(newsList));
```

### 3. 恢复状态

切换到新分类时：

```java
String newCategoryKey = categoryCode == null ? "all" : categoryCode;

if (categoryDataMap.containsKey(newCategoryKey)) {
    // 之前访问过，直接恢复
    currentOffset = categoryOffsetMap.get(newCategoryKey);
    hasMoreData = categoryHasMoreMap.get(newCategoryKey);
    List<NewsItem> savedData = categoryDataMap.get(newCategoryKey);
    
    newsList.clear();
    newsList.addAll(savedData);
    newsAdapter.notifyDataSetChanged();
    
    // 同步状态到Adapter
    newsAdapter.setHasMoreData(hasMoreData);
    newsAdapter.setShowLoadMore(true);
} else {
    // 第一次访问，从服务器加载
    loadNewsWithCache();
}
```

---

## 📊 使用场景

### 场景1：科技板块多次加载

```
1. 打开应用 → 显示"全部"板块（2条新闻）
2. 点击"科技" → 加载2条科技新闻
3. 点击"加载更多" → 追加2条（总共4条）
4. 再点击"加载更多" → 追加2条（总共6条）
5. 切换到"经济"板块
6. 再切换回"科技"板块
   ✅ 直接显示6条新闻，无需重新加载
   ✅ 可以继续点击"加载更多"加载第7、8条
```

### 场景2：多个分类独立状态

```
全部板块：offset=0, 数据量=2, hasMore=true
  ↓ 切换
科技板块：offset=0, 数据量=2, hasMore=true
  ↓ 加载更多
科技板块：offset=2, 数据量=4, hasMore=true
  ↓ 切换
经济板块：offset=0, 数据量=2, hasMore=true
  ↓ 切换回科技
科技板块：offset=2, 数据量=4, hasMore=true ✅ 状态完全保留
```

---

## 🎨 用户体验

### 1. 提示信息
切换到已访问过的分类时，显示Toast提示：
```
"已恢复【科技】的浏览状态"
```

### 2. 日志输出
在Logcat中可以看到详细的状态保存和恢复过程：
```
💾 保存【tech】状态: offset=4, hasMore=true, 数据量=4
📂 恢复【tech】: offset=4, hasMore=true, 数据量=4
🆕 首次访问【economy】，从服务器加载
```

---

## ⚠️ 注意事项

### 1. 内存占用
每个分类的数据都保存在内存中，如果分类很多且每个分类加载很多数据，可能会占用较多内存。

**当前情况**：
- 8个分类
- 每个分类最多15条新闻
- 每条新闻约1KB
- 总内存占用：约120KB（可忽略）

### 2. 数据刷新
下拉刷新时，会清空当前分类的缓存，重新加载：
```java
// 重置到第一页
currentOffset = 0;
hasMoreData = true;
loadNewsWithCache();
```

### 3. 生命周期
状态只在应用运行期间保存，关闭应用后会丢失。如需持久化，可以考虑：
- 使用SharedPreferences保存offset和hasMoreData
- 使用Room数据库保存所有已加载的新闻

---

## 📝 与本地缓存的区别

### 内存状态保持（本功能）
- ✅ 即时恢复，无需等待
- ✅ 包含所有加载过的数据
- ❌ 关闭应用后丢失

### Room本地缓存
- ✅ 持久化保存
- ✅ 离线可用
- ❌ 只缓存第一页数据
- ❌ 需要异步加载

### 最佳实践
两者结合使用：
1. **首次打开应用**：从Room缓存加载数据（离线可用）
2. **切换分类**：从内存恢复状态（即时响应）
3. **下拉刷新**：从服务器加载最新数据，更新缓存
4. **关闭应用**：Room缓存保留，内存状态清空

---

## 🔄 完整流程

### 第一次访问"科技"
```
用户点击"科技" 
  ↓
检查：categoryDataMap中没有"tech"
  ↓
从服务器加载 offset=0, limit=2
  ↓
返回2条数据，显示
  ↓
保存到categoryDataMap["tech"] = [news1, news2]
```

### 第二次访问"科技"（点击加载更多后）
```
用户点击"经济"
  ↓
保存：categoryDataMap["tech"] = [news1, news2, news3, news4]
     categoryOffsetMap["tech"] = 2
  ↓
用户再点击"科技"
  ↓
检查：categoryDataMap中有"tech"
  ↓
直接恢复：显示4条数据，offset=2
  ↓
可以继续点击"加载更多"
```

---

**更新时间**: 2025-11-23  
**功能版本**: v1.0
